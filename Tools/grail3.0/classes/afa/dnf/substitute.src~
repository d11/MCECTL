/******************************************************************************************
 File: 	classes/afa/dnf/substitute.src
 -----

 Description:
 ------------
	This file contains the definition of the function 
	funct funct::substitute(int* x, funct* f, int n) const.
	
	This is a public member of the funct class (declared in funct.h)

Revision History:
 -----------------
	X. Wu				Initial version of source code
	S. Huerter 08/11/98		Header and comments

******************************************************************************************/

	funct funct::substitute(int* X, funct* F, int n) const

Description:
	This function returns the funct resulting from substituting the function
        F[X[i-1]] for the ith variable in this function, i=1..n. It is assumed that
	the number of Boolean variables and the the size of array X is the same. It
	is the responsibility of the calling function to ensure all integers in array
	X are in fact indices into array F.

Parameters
	int *X				-array of integers
	funct *F			-array of funct 's
	int n 				-the number of Boolean var in this funct

/******************************************************************************************/
#include "function.h"
/******************************************************************************************/
funct funct::substitute(int* x, funct* f, int n) const
{
    funct result;

    term* ptr = head;
    while (ptr != 0)
       {
    	  funct tmp;
	  unsigned alpha, beta;
	  alpha = ptr->get_alpha();
	  beta = ptr->get_beta();
	
	  if (alpha !=0)
	     {
	        tmp.append(term(0,0));
	        for (int i = 0; i<n; i++)
	           {
		      unsigned t = (unsigned) pow(2, i);
		      if ((alpha & t) != 0)
		         {
		            if ((beta & t) != 0)
	       		       tmp =tmp.and(f[x[i]-1]);
			    else
			       {
				  funct negation;
				  negation = f[x[i]-1].not();
                                  tmp= tmp.and(negation);
			       }
		         }
	           }
	     }
	  else
	     {
		if (beta == 0)
		   tmp.append(term(0,0));
		else
		   tmp.append(term(0,1));
	     }
	  result.append(tmp);
	  ptr = ptr->get_next();
       }

    return result;
}



