/***************************************************************************

   This file contains the definitions of data structures and procedures
   for defining variables, and for initializing the BDD manager to deal
   with these variables.

   ************************************************************************/

#ifndef INT_H
#define INT_H

#include "intInt.h"


/***************************************************************************/
/* Data structures for defining modules and variables:                     */

/* This defines a procedure and the variables in it. A list of these
   is needed by the initialization procedure (see below). */
typedef struct intModule
{
	wIdent name;	/* The name of the module (optional).		*/
	struct wSet *labels;	/* Stack symbols belonging to this module.  */
	struct intVariable *vars;  /* The local variables of this module.   */
	struct intModule *next;	   /* for creating a linked list of modules */
} intModule;

/* Simple data structure for creating
   a list of stack symbols. */
typedef struct wSet
{
	wIdent ident;
	struct wSet *next;
} wSet;

/* This defines a scalar variable or an array. */
typedef struct intVariable
{
	wIdent name;	/* The name of the variable */
	char type;	/* type = 0 means boolean,
			   type = n>0 means integer with n bits */
	int dim;	/* dim = 0 means scalar variable,
			   dim = n>0 means array with n entries. */
	int low_index;	/* For arrays, indicates the lowest index.
			   For scalars, this field is meaningless. */

	int bddindex;		/* Internal use. Do not touch. */
	intModule *module;	/* Internal use. Do not touch. */

	struct intVariable *next;	/* Next variable in the same module. */
} intVariable;


/***************************************************************************/
/* Data structures for expressions over variables:                         */

/* This is used to indicate an occurrence of a variable in an expression. */
typedef struct intVarRef
{
	intVariable *var;	/* Pointer to the variable. */
	char primes;		/* how many "primes" (0,1,2) */
	struct intExpr* index;	/* When accessing an array element, put the
				   expression in [ ] here. NULL for scalars. */

	/* The following fields are for internal use by intPdsInsert. */
	DdNode **context;
	int value, maxval;
	struct intVarRef* next;
} intVarRef;

/* Structure for a quantified variable */
typedef struct intQuantifier
{
	wIdent name;	/* The name. For convenience, not evaluated. */
	int lower;	/* Lower and upper bound of the range. */
	int upper;	/*  (Constant bounds only, at least for now.) */

	int value;	/* Internal use. Do not touch. */
} intQuantifier;

/* Node types for expression trees: */
typedef enum {
	EXPR_OR, EXPR_AND, EXPR_EQV, EXPR_XOR,	/* Binary boolean operators */
	EXPR_NOT,				/* Unary boolean operator */
	EXPR_FORALL, EXPR_EXISTS,		/* Quantifiers */
	EXPR_VAR, 				/* Bool or int variable */
	/* One of the following six binary integer comparison operators
	   must be in the topmost node of an integer expression: */
	EXPR_LT, EXPR_LE, EXPR_EQ, EXPR_NE, EXPR_GE, EXPR_GT,
	/* Binary int ops: */
	EXPR_PLUS, EXPR_MINUS, EXPR_MULT, EXPR_DIV, EXPR_SHL, EXPR_SHR,
    EXPR_BIT_AND, EXPR_BIT_OR, EXPR_BIT_XOR,
	EXPR_QVAR,		/* Quantified variable */
	EXPR_CONST		/* Integer constant */
} intExprToken;

/* Instructions for expression trees (see below):
   `type' is always one of the constants above.
   Binary operators use `left' and `right' for their subexpressions.
   Unary operators (i.e. NOT) use `left'.
   Quantifiers use `q' to indicate the quantified variable,
	and `left' for the quantified subexpression.
   EXPR_VAR uses the `var' element.
   EXPR_QVAR uses the 'q' element (point to same address as the quantifier).
   EXPR_CONST uses the `value' element.
   Note: An EXPR_CONST node with a non-zero value outside of an integer
	 expression is interpreted as 'true', a zero value as 'false'.
*/
   
typedef struct intExpr
{
	intExprToken type;
	struct intExpr *left, *right;
	struct intQuantifier *q;
	struct intVarRef *vref;
	int value;
} intExpr;


/***************************************************************************/
/* Data structures for intPds and for analysing them:                      */

/* The following data structure is generated by intGeneratedPds.
   It contains a "pushdown system with bdds" and some other information
   that relates BDDs to variables. */

typedef struct intPds
{
	bddPds *pds;
	intModule *modules;
} intPds;

#define intProblem bddProblem

/* Data attached to a stack element of a configuration in a counterexample.
   refcount is for internal use, do not touch.
   The stack is formed by following the rest_path pointer. */

typedef struct intValuation
{
	intVariable *var;
	union {
		int integer;
		int* array;
	} value;
	struct intValuation *next;
} intValuation;

typedef struct intPath
{
	wIdent stack;
	intValuation *values;	/* local variables belonging to 'stack' */
	int refcount;
	struct intPath *rest_path;
} intPath;

/* A configuration in a counterexample.
   Configurations form a linked list connected by the next_config field.
   stack points to the stack contents (another linked list, see above). */
   
typedef struct intConfig
{
	wIdent state;
	intValuation *values;	/* global variables */
	struct intPath *prefix;
	struct intPath *stack;
	struct intConfig *next_config;
} intConfig;

/* The data returned by the model-checking algorithms. */
typedef struct intResult
{
	bddResultType yesno;	/* either RESULT_YES or RESULT_NO */
	intConfig *prefix;	/* prefix of counterexample, if appropriate */
	intConfig *loop;	/* loop of counterexample, if appropriate */
				/* loop==NULL for reachability */
} intResult;


/***************************************************************************/
/* Functions:                                                              */

/* This sets up the BDD manager, creates BDD variables for all the variables
   in the program and so forth. It must be called after the program has been
   parsed (i.e. when all the program variables are known), and before any
   BDDs can be created.
 
   The first arguments is the initial configuration.
   The second argument is a list of modules. The first entry of the list
   is interpreted as the "global" module, i.e. the variables in it are
   the global variables. All other entries in the list are modules with
   lists of local variables.

   Note: The intPds procedures keep pointers to the intModule data,
	 which means that you should not destroy or modify that data while
	 the pds is alive. Also, that data will be destroyed by intPdsDelete,
	 so create a copy if you want to keep it...
   Note: The variable lists of nested modules must also contain the local
	 variables of their parent modules.
*/
extern intPds* intPdsCreate (wConfig*, intModule*);

/* Generates a rule in the pushdown system that is annotated with
   a BDD generated from the intExpr. The procedure will make some
   changes to the expression tree. Afterwards, the tree is no longer
   needed and may be destroyed (using intExprDelete). */
extern wRule* intPdsInsert(intPds*,wIdent,wIdent,wIdent,wIdent,wIdent,intExpr*);

/* Destroy an intPds. */
extern void intPdsDelete (intPds*);

/***************************************************************************/

/* Functions related to sets of identifiers (e.g. list of stack symbols): */

/* Generate a new empty set (simply a NULL pointer). */
extern wSet* wSetCreate ();

/* Add an identifier to a set. This operation may change the
   address of the set (therefore the wSet** argument). */
extern void wSetInsert (wSet**,wIdent);

/* Check if an identifier is contained in a set
   and return 1 if it is found, 0 otherwise. */
extern int wSetFind (wSet*,wIdent);

/* Remove the memory occupied by a set. */
extern void wSetDelete (wSet*);

/***************************************************************************/
/* For convenience, here are procedures for generating the various
   types of nodes in an expression tree and filling them with data.
   In intExprBinary and intExprQuantified, the char argument is the
   expression type. The other arguments follow the definitions of
   the node types they generate. */
extern intExpr* intExprBinary (char,intExpr*,intExpr*);
extern intExpr* intExprQuantified (char,intQuantifier*,intExpr*);
extern intExpr* intExprVarRef (intVariable*,char,intExpr*);
extern intExpr* intExprQvar (intQuantifier*);
extern intExpr* intExprConst (int);
extern intQuantifier* intCreateQuantifier (wIdent,int,int);

/* Recursively delete the expression tree rooted at the argument. */
extern void intExprDelete (intExpr*);

/***************************************************************************/
/* Functions for analysing an intPds. These use the corresponding
   functions from bddPds and then translate the results into the
   terms of the intPds. */
extern intResult* intPostReachability (intPds*,wIdent,wIdent);
extern intResult* intAnalyse (intPds*,intProblem*);
extern void intPrintResult (intPds*,intResult*);
extern void intDeleteResult (intPds*,intResult*);

#endif
